 This implementation is with Unix sockets to build a server for a text-based battle game, modelled after a Pokemon battle where no client is needed. open the makefile to see that you have the option of choosing the port number that the server will run on. When starting "battle" server, open up a shell and type 
 "stty -canon; nc localhost <PORTNUMBER>"
 where you specify the port number that the server will be running on. By default, this is port 31313.


 Once you've connected, you'll be asked for your name. Type something (Dan, for example) and hit enter. You'll then be told that you are waiting for an opponent, and you will be stuck there until someone else connects to the server. So, instead of waiting for someone else to log-in, just open another terminal and connect to it from there too. (If you're using ssh, you can just start a new ssh instance. You could also job control back and forth between two nc instances running on the same terminal.) You will be asked for the name of this second client; type something (Karen, for example) and hit enter.

At this point, two players are available, so they will engage in combat, with one of the two players randomly earning first strike. Prior to each match (i.e. battle), each player is given a random number of hitpoints and a random number of powermoves. (It doesn't matter how many hitpoints or powermoves you had remaining after a match; when the next match starts, these stats are freshly randomized.) Players repeatedly exchange attacks, until one of the players loses by virtue of having 0 hitpoints remaining.

There are two kinds of attacks: you can press a for a regular attack or p for a powermove. Regular attacks are weak but guaranteed to hit; powermoves are strong, but not guaranteed to hit, and limited in number. Also, you'll notice that a player is unaware of the quantity of powermoves held by their opponent. So you never know whether your opponent is saving a powermove for later or they are all out of powermoves.

As per the menus printed by the battle server, the other available option is to (s)ay something. Only the currently-attacking player can talk, and saying something does not take up a turn. It's like in-game messaging. I trust we will all play nice.

Similar to when you entered your name, no text is sent to your opponent until you hit enter. That is, the server is buffering a full line. Remember that stty -icanon command we ran earlier? That command causes each character to be fired out as soon as you press it at the keyboard. (You noticed this when pressing a or p; the action happened immediately, and you didn't have to hit enter first.) So it's the server here that's buffering the text until it gets a newline.

Play around with attacking, powermoving, and sending text, until the match is over. At that point, Dan and Karen are still connected, waiting for new opponents. Importantly, you'll notice that they won't battle again; they'll just sit there waiting for someone else to come online. (Consider what would happen if they were allowed to battle again: after their first match, they'd likely be the only two people free and would battle again and again and again.) So, add a third client, and that third client will then engage one of the two existing clients. Add a fourth client, and they will engage the lone player not currently in a battle. This also shows that multiple matches can occur simultaneously and independently. The server never blocks waiting for anything; only matches with new action are serviced.

The last thing I'd like to highlight here is what happens when a client drops. Initiate a match between two players, and then hit ctrl+c on one of them to kill their nc process. Switch to the remaining client's window; you'll notice that this client is deemed the winner, and that they go back to seeking another opponent.

When you're finished, type stty icanon at the shell to return the terminal back to canonical mode. If you don't do this, programs will work in unexpected ways. (For example, do a stty -icanon to get back to noncanonical mode, then type cat. You'll notice that instead of waiting for full lines, each character is echoed by cat as soon as you type it.)